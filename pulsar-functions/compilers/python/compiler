#!/usr/bin/env python3
"""Python Action Builder
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""

import os, os.path, sys, shutil
from os.path import abspath, exists, dirname


# write a file creating intermediate directories
def write_file(file, body, executable=False):
    try:
        os.makedirs(dirname(file), mode=0o755)
    except:
        pass
    with open(file, mode="wb") as f:
        f.write(body.encode("utf-8"))
    if executable:
        os.chmod(file, 0o755)


# copy a file eventually replacing a substring
def copy_replace(src, dst, match=None, replacement=""):
    with open(src, 'rb') as s:
        body = s.read()
        if match:
            body = body.decode("utf-8").replace(match, replacement)
        write_file(dst, body, True)


# assemble sources
def sources(lib, launcher, main, src_dir):
    # write the boilerplate in a temp dir
    shutil.copytree(lib, "%s/lib" % src_dir)
    copy_replace(launcher, "%s/exec__.py" % src_dir, "CLASS_NAME", main)


# build virtualenv if there is a requirements.txt
def virtualenv(tgt_dir):
    # check virtualenv
    virtualenv_dir = abspath('%s/virtualenv' % tgt_dir)
    requirements_txt = abspath("%s/requirements.txt" % tgt_dir)
    if exists(requirements_txt):
        if not os.path.isdir(virtualenv_dir):
            cmd = "python -m virtualenv %s >/tmp/err 2>/tmp/err" % virtualenv_dir
            if os.system(cmd) != 0:
                with open("/tmp/err", "r") as f:
                    sys.stderr.write(f.read())
            else:
                cmd = ". %s/bin/activate && python -m pip install -r %s >/tmp/err 2>/tmp/err" % (
                    virtualenv_dir, requirements_txt)
                if os.system(cmd) != 0:
                    with open("/tmp/err", "r") as f:
                        sys.stderr.write(f.read())
    sys.stderr.flush()


# compile sources
def build(src_dir, tgt_dir):
    # in general, compile your program into an executable format
    # for scripting languages, move sources and create a launcher
    # move away the action dir and replace with the new
    try:
        shutil.rmtree(tgt_dir)
    except:
        pass
    shutil.move(src_dir, tgt_dir)
    tgt_file = "%s/exec" % tgt_dir
    write_file(tgt_file, """#!/bin/bash
export PYTHONIOENCODING=UTF-8
cd "$(dirname $0)"
source virtualenv/bin/activate || true
./exec__.py "$@"
""", True)
    return tgt_file


if __name__ == '__main__':
    if len(sys.argv) < 4:
        sys.stdout.write("usage: <main-function> <source-dir> <target-dir>\n")
        sys.stdout.flush()
        sys.exit(1)
    lib = "%s/python/lib" % dirname(dirname(sys.argv[0]))
    launcher = "%s/python/launcher.py" % dirname(dirname(sys.argv[0]))
    src_dir = abspath(sys.argv[2])
    tgt_dir = abspath(sys.argv[3])
    sources(lib, launcher, sys.argv[1], src_dir)
    build(abspath(sys.argv[2]), tgt_dir)
    virtualenv(tgt_dir)
    sys.stdout.flush()
    sys.stderr.flush()
